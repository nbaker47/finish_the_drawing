
</html>

<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<meta charset="UTF-8">
<head>
    <title>Finish the Drawing!</title>

    <link rel="icon" href="{{ url_for('static', filename='media/favicon1.ico') }}" sizes="any">
    <link rel="shortcut icon" href="{{ url_for('static', filename='media/favicon1.ico') }}" sizes="any">

    <link rel="apple-touch-icon" href="{{ url_for('static', filename='media/apple-touch-icon.png') }}">

    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/bootstrap.css') }}">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/home.css') }}">
    <!--<link rel="manifest" href="/manifest.json" />-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#161616">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Finish the Drawing!">

</head>
<body>

    <link rel="icon" href="{{ url_for('static', filename='media/favicon1.ico') }}" sizes="any">

<div class='master-container index-container'>
    
  <!--Title-->
  <div class="text-center custom-title">
      <!--<span class=''> Today, finish this drawing of a:</span>-->
      <img src="https://fontmeme.com/permalink/230708/6d7b11b0ef475bbee778dfe5f61a4c73.png" alt="handwriting-fonts" border="0">
      <div class='bounce-in'>
        <span class=" emph-title">"{{word}}"</span>
      </div>
  </div>

  <!-- Drawing interface -->
  <div class="text-center drawing-interface">
    <div class='inner-interface'>
      <!-- Canvas -->
      <canvas id="drawing-canvas" width="400" height="350"></canvas>
      <!-- Submit button and Back button -->
      <div class="text-center button-container d-flex want-to-gray">
        <button id="back-button" class="btn mx-auto back-button custom-button" onclick="undoLastStroke()"><i class="fas fa-undo"></i></button>
        <button id="submit-button" class="btn mx-auto submit-feedback custom-button" onclick="submitDrawing()">Submit</button>
      </div>
    </div>
  </div>


  <!-- Footer -->
  <footer class="footer p-1 text-center">
    <div class="container text-center footer-container">
        <div class="row d-flex align-items-center">

            <div class="col-3">
                <div class="settings-icon want-to-invert" onclick="openSettingsTab()">
                  <i class="fas fa-cog " style="color: #000000;"></i>
                </div>
                <div id="settings-tab" class="settings-tab want-to-invert">
                      <input type="range" min="1" max="3" value="1" class="slider" id="myRange">
                      <input type="range" min="1" max="2" value="1" class="slider" id="myRangeTheme">
                </div>
            </div>

            <div class="col-6">
                <span>2023 Finish the Drawing Â©</span>
            </div>

            <div class="col-3 d-flex justify-content-end">
                <div class="email-icon want-to-invert" onclick="openEmailTab()">
                    <i class="fa-regular fa-envelope fa-lg" style="color: #000000;padding-top: 12px;"></i>
                </div>
                <div id="email-tab" class="email-tab want-to-invert">
                    <span>finishthedrawing.contact@gmail.com</span>
                </div>
            </div>

        </div>
    </div>
  </footer>

</div>



<!--jQuery-->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<!--Bootstrap JS-->
<script src="{{ url_for('static', filename='js/bootstrap.js') }}"></script>
<!--Service Worker
<script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register("/service-worker.js?v4")
          .then(function(registration) {
            console.log('Service Worker registered with scope:', registration.scope);
          })
          .catch(function(error) {
            console.error('Service Worker registration failed:', error);
          });
      });
    }
</script>
-->

<!-- submit button -->
<script>
    function submitDrawing() {
        var canvas = document.getElementById('drawing-canvas');
        var image = canvas.toDataURL(); // Convert canvas to base64 image
    
        // Create a form and append the image data
        var form = document.createElement('form');
        form.action = '/submit';
        form.method = 'POST';
        // form.enctype = 'multipart/form-data'; // Set the enctype attribute
    
        var input = document.createElement('input');
        input.type = 'hidden';
        input.name = 'image';
        input.value = image;
    
        form.appendChild(input);
    
        document.body.appendChild(form);
    
        // Submit the form
        form.submit();
    }
</script>


<!-- Canvas Drawing -->
<script>
  // Variables for canvas and drawing
  var canvas = document.getElementById('drawing-canvas');
  var context = canvas.getContext('2d');
  var isDrawing = false;
  var isFirstTouch = true; // Flag to differentiate between first touch and random lines
  var userDrawings = []; // Array to store user's drawings
  var currentLine = null; // Variable to store the current line segment

  // Event listeners for drawing
  canvas.addEventListener('mousedown', startDrawing);
  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('mouseup', stopDrawing);
  canvas.addEventListener('mouseout', stopDrawing);

  // Touch event listeners for drawing
  canvas.addEventListener('touchstart', startDrawing);
  canvas.addEventListener('touchmove', draw);
  canvas.addEventListener('touchend', stopDrawing);

  // Get the scale factor for transforming screen space to canvas space
  function elementScale() {
    let el = canvas;
    return el.width / el.offsetWidth;
  }

  // Get cursor coordinates
  function getXY() {
    let rect = canvas.getBoundingClientRect();
    let x_temp, y_temp;

    if (event.type.startsWith('touch')) {
      x_temp = (event.touches[0].clientX - rect.left) * elementScale();
      y_temp = (event.touches[0].clientY - rect.top) * elementScale();
    } else {
      x_temp = (event.clientX - rect.left) * elementScale();
      y_temp = (event.clientY - rect.top) * elementScale();
    }

    return [x_temp, y_temp];
  }


  // Start drawing function
  function startDrawing(event) {
    event.preventDefault(); // Prevent scrolling on touch devices
    isDrawing = true;

    // Get the coordinates of the cursor
    let [x_temp, y_temp] = getXY();
    // console.log(x_temp, y_temp);

    // Set the starting point of the line segment
    currentLine = {
      points: [{ x: x_temp, y: y_temp }],
    };
  }

  // Draw on the canvas
  function draw(event) {
    // Get the coordinates of the cursor
    let [x_temp, y_temp] = getXY();
    // console.log(x_temp, y_temp);

    if (!isDrawing) return;
    context.lineWidth = 5;
    context.lineCap = 'round';
    context.strokeStyle = 'black';

    currentLine.points.push({ x: x_temp, y: y_temp });

    // clear the canvas
    context.clearRect(0, 0, canvas.width, canvas.height);
    // redraw random lines:
    drawRandomLines();

    userDrawings.forEach(function (line) {
      context.beginPath();
      context.moveTo(line.points[0].x, line.points[0].y);
      for (var i = 1; i < line.points.length; i++) {
        context.lineTo(line.points[i].x, line.points[i].y);
      }
      context.stroke(); 
    });

    context.beginPath();
    context.moveTo(currentLine.points[0].x, currentLine.points[0].y);
    for (var i = 1; i < currentLine.points.length; i++) {
      context.lineTo(currentLine.points[i].x, currentLine.points[i].y);
    }
    context.stroke();
  }

  // Stop drawing
  function stopDrawing() {
    if (!isDrawing) return;
    isDrawing = false;
    // Store the completed line segment in the userDrawings array
    userDrawings.push(currentLine);
  }

  // Undo the last line segment drawn by the user
  function undoLastStroke() {
    // Remove the last line segment from the userDrawings array
    userDrawings.pop();

    // Clear the canvas
    context.clearRect(0, 0, canvas.width, canvas.height);
    // redraw random lines:
    drawRandomLines();

    // Redraw all the user's line segments
    userDrawings.forEach(function (line) {
      context.beginPath();
      context.moveTo(line.points[0].x, line.points[0].y);
      for (var i = 1; i < line.points.length; i++) {
        context.lineTo(line.points[i].x, line.points[i].y);
      }
      context.stroke();
    });
  }

  // Draw all randomly generated lines
  function drawRandomLines() {
    context.clearRect(0, 0, canvas.width, canvas.height);

    context.lineWidth = 5;
    context.lineCap = 'round';
    context.strokeStyle = 'black';

    randomLines.forEach(function (linePoints) {
      context.beginPath();
      context.moveTo(linePoints[0].x, linePoints[0].y);
      for (var i = 1; i < linePoints.length; i++) {
        context.lineTo(linePoints[i].x, linePoints[i].y);
      }
      context.stroke();
    });
  }

</script>


<!-- Random Lines -->
<script>
  // Array to store randomly generated lines
  var randomLines = [];

  // Add wavy line traversal to the canvas
  function addRandomLines() {
    var n = 500; // Number of line segments
    var a = 0.1; // Angle aperture parameter
    var boundaryRange = 0.7; // Percentage of the canvas width/height to stay within
    var minLength = Math.min(canvas.width, canvas.height) * 0.3; // Minimum length of the line

    var canvasWidth = canvas.width;
    var canvasHeight = canvas.height;

    var centerX = canvasWidth / 2;
    var centerY = canvasHeight / 2;

    var boundaryWidth = canvasWidth * boundaryRange;
    var boundaryHeight = canvasHeight * boundaryRange;

    var startX = centerX - boundaryWidth / 2 + Math.random() * boundaryWidth;
    var startY = centerY - boundaryHeight / 2 + Math.random() * boundaryHeight;

    var x = startX;
    var y = startY;
    var angle = 0;
    var lineLength = 0;

    context.lineWidth = 5;
    context.lineCap = 'round';
    context.strokeStyle = 'black';

    var linePoints = []; // Array to store the points of the current line

    context.beginPath();
    context.moveTo(x, y);

    for (var k = 1; k <= n; k++) {
      var angleVariation = (2 * Math.random() - 1) * a * Math.PI;
      angle += angleVariation;

      // Calculate the maximum distance from the boundary
      var maxDistanceX = Math.min(boundaryWidth / 2 - Math.abs(x - centerX), boundaryWidth / 2);
      var maxDistanceY = Math.min(boundaryHeight / 2 - Math.abs(y - centerY), boundaryHeight / 2);

      var maxLength = Math.min(maxDistanceX, maxDistanceY);

      // Calculate the remaining length to reach the minimum length
      var remainingLength = minLength - lineLength;
      var r = Math.min(remainingLength, Math.random() * maxLength);

      x += r * Math.cos(angle);
      y += r * Math.sin(angle);

      lineLength += r;

      context.lineTo(x, y);
      linePoints.push({ x: x, y: y });

      // Exit the loop if the line reaches the minimum length
      if (lineLength >= minLength) {
        break;
      }
    }

    context.stroke();

    randomLines.push(linePoints); // Store the points of the line in the array
  }



  // Drawing random lines
  window.addEventListener('load', function() {
    // Call the function to add random lines when the page loads
    for (var i = 0; i < 5; i++) {
      addRandomLines();
    }
    // Clear the canvas
    context.clearRect(0, 0, canvas.width, canvas.height);
    // redraw random lines:
    drawRandomLines();
  });
</script>



<!--Slider-->
<script>
  // emotion
  const slide = document.getElementById('myRange');
  var imageUrl = "url('happy.png')";
  document.documentElement.style.setProperty('--dynamicImage', imageUrl);

  slide.addEventListener('input', function() {

    switch (this.value) {
      case '1':
        imageUrl = "url('happy.png')";
        break;
      case '2':
        imageUrl = "url('neutral.png')";
        break;
      case '3':
        imageUrl = "url('sad.png')";
        break;
    }

    document.documentElement.style.setProperty('--dynamicImage', imageUrl);
    // Set random descriptions for each span element
    for (let i = 0; i < spanElements.length; i++) {
      spanElements[i].textContent = getRandomDescription(this.value);
    }
    for (let i = 0; i < cardFooters.length; i++) {
      shrinkTextToFit(cardFooters[i]);
    }
  });

  // theme
  const slideTheme = document.getElementById('myRangeTheme');
  slideTheme.addEventListener('input', function() {
    
    var element = document.body;
    element.classList.toggle("dark-mode");

    var element2 = document.getElementsByClassName('card-footer');
    for (let i = 0; i < element2.length; i++) {
      element2[i].classList.toggle("dark-mode");
      element2[i].classList.toggle("dark-mode-box");
    }

    var element3 = document.getElementsByClassName('footer');
    for (let i = 0; i < element3.length; i++) {
      element3[i].classList.toggle("dark-mode");
      element3[i].classList.toggle("dark-mode-box");
    }

    var element4 = document.getElementsByClassName('want-to-invert');
    for (let i = 0; i < element4.length; i++) {
      element4[i].classList.toggle("inverted-color");
    }

    var element5 = document.getElementsByClassName('button-container');
    for (let i = 0; i < element5.length; i++) {
      element5[i].classList.toggle("dark-mode");
      element5[i].classList.toggle("dark-mode-box");
    }

  });

  function openSettingsTab() {
    var settingsTab = document.getElementById('settings-tab');
    if (settingsTab.style.display === '' || settingsTab.style.display === 'none') {
      settingsTab.style.display = 'block';
    } else {
      settingsTab.style.display = 'none';
    }
  }

  function openEmailTab(){
    var emailTab = document.getElementById('email-tab');
    if (emailTab.style.display === '' || emailTab.style.display === 'none') {
      emailTab.style.display = 'block';
    } else {
      emailTab.style.display = 'none';
    }
  }
  
</script>

</body>
</html>
