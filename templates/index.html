
</html>

<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<meta charset="UTF-8">
<head>
    <title>Finish the Drawing!</title>

    <link rel="icon" href="{{ url_for('static', filename='media/favicon1.ico') }}" sizes="any">
    <link rel="shortcut icon" href="{{ url_for('static', filename='media/favicon1.ico') }}" sizes="any">

    <link rel="apple-touch-icon" href="{{ url_for('static', filename='media/apple-touch-icon.png') }}">

    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/bootstrap.css') }}">
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/home.css') }}">
    <!--<link rel="manifest" href="/manifest.json" />-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#161616">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Immerse Lingual is a web app that allows you to read classical Chinese texts with a built-in dictionary.">

</head>
<body>

    <link rel="icon" href="{{ url_for('static', filename='media/favicon1.ico') }}" sizes="any">

<div class='master-container'>
    
  <!--Title-->
  <div class="text-center custom-title">
      <span class=''> Today, finish this drawing of a:</span>
      <div class='bounce-in'>
        <span class=" emph-title">"{{word}}"</span>
      </div>
  </div>

  <!-- Drawing interface -->
  <div class="text-center drawing-interface">
    <div class='inner-interface'>
      <!-- Canvas -->
      <canvas id="drawing-canvas" width="400" height="350"></canvas>
      <!-- Submit button and Back button -->
      <div class="text-center button-container">
        <button id="back-button" class="btn mx-auto back-button custom-button" onclick="undoLastStroke()"><i class="fas fa-undo"></i></button>
        <button id="submit-button" class="btn mx-auto submit-feedback custom-button" onclick="submitDrawing()">Submit</button>
      </div>
    </div>
  </div>

</div>

<!--jQuery-->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<!--Bootstrap JS-->
<script src="{{ url_for('static', filename='js/bootstrap.js') }}"></script>
<!--Service Worker
<script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register("/service-worker.js?v4")
          .then(function(registration) {
            console.log('Service Worker registered with scope:', registration.scope);
          })
          .catch(function(error) {
            console.error('Service Worker registration failed:', error);
          });
      });
    }
</script>
-->

<!-- submit button -->
<script>
    function submitDrawing() {
        var canvas = document.getElementById('drawing-canvas');
        var image = canvas.toDataURL(); // Convert canvas to base64 image
    
        // Create a form and append the image data
        var form = document.createElement('form');
        form.action = '/submit';
        form.method = 'POST';
        // form.enctype = 'multipart/form-data'; // Set the enctype attribute
    
        var input = document.createElement('input');
        input.type = 'hidden';
        input.name = 'image';
        input.value = image;
    
        form.appendChild(input);
    
        document.body.appendChild(form);
    
        // Submit the form
        form.submit();
    }
</script>


<!-- Canvas Drawing -->
<script>
  // Variables for canvas and drawing
  var canvas = document.getElementById('drawing-canvas');
  var context = canvas.getContext('2d');
  var isDrawing = false;
  var isFirstTouch = true; // Flag to differentiate between first touch and random lines
  var userDrawings = []; // Array to store user's drawings
  var currentLine = null; // Variable to store the current line segment

  // Event listeners for drawing
  canvas.addEventListener('mousedown', startDrawing);
  canvas.addEventListener('mousemove', draw);
  canvas.addEventListener('mouseup', stopDrawing);
  canvas.addEventListener('mouseout', stopDrawing);

  // Touch event listeners for drawing
  canvas.addEventListener('touchstart', startDrawing);
  canvas.addEventListener('touchmove', draw);
  canvas.addEventListener('touchend', stopDrawing);

  // get cursor coords
  function getXY() {
    // Get the coordinates based on the event type
    let rect = canvas.getBoundingClientRect();
    let x_temp, y_temp;

    if (event.type.startsWith('touch')) {
      x_temp = event.touches[0].clientX - rect.left;
      y_temp = event.touches[0].clientY - rect.top;
    } else {
      x_temp = event.clientX - rect.left;
      y_temp = event.clientY - rect.top;
    }
    // console.log(x_temp, y_temp);
    return [x_temp, y_temp];
  }

  // Start drawing function
  function startDrawing(event) {
    event.preventDefault(); // Prevent scrolling on touch devices
    isDrawing = true;

    // Get the coordinates of the cursor
    let [x_temp, y_temp] = getXY();
    // console.log(x_temp, y_temp);

    // Set the starting point of the line segment
    currentLine = {
      points: [{ x: x_temp, y: y_temp }],
    };
  }

  // Draw on the canvas
  function draw(event) {
    // Get the coordinates of the cursor
    let [x_temp, y_temp] = getXY();
    // console.log(x_temp, y_temp);

    if (!isDrawing) return;
    context.lineWidth = 5;
    context.lineCap = 'round';
    context.strokeStyle = 'black';

    currentLine.points.push({ x: x_temp, y: y_temp });

    // clear the canvas
    context.clearRect(0, 0, canvas.width, canvas.height);
    // redraw random lines:
    drawRandomLines();

    userDrawings.forEach(function (line) {
      context.beginPath();
      context.moveTo(line.points[0].x, line.points[0].y);
      for (var i = 1; i < line.points.length; i++) {
        context.lineTo(line.points[i].x, line.points[i].y);
      }
      context.stroke(); 
    });

    context.beginPath();
    context.moveTo(currentLine.points[0].x, currentLine.points[0].y);
    for (var i = 1; i < currentLine.points.length; i++) {
      context.lineTo(currentLine.points[i].x, currentLine.points[i].y);
    }
    context.stroke();
  }

  // Stop drawing
  function stopDrawing() {
    if (!isDrawing) return;
    isDrawing = false;
    // Store the completed line segment in the userDrawings array
    userDrawings.push(currentLine);
  }

  // Undo the last line segment drawn by the user
  function undoLastStroke() {
    // Remove the last line segment from the userDrawings array
    userDrawings.pop();

    // Clear the canvas
    context.clearRect(0, 0, canvas.width, canvas.height);
    // redraw random lines:
    drawRandomLines();

    // Redraw all the user's line segments
    userDrawings.forEach(function (line) {
      context.beginPath();
      context.moveTo(line.points[0].x, line.points[0].y);
      for (var i = 1; i < line.points.length; i++) {
        context.lineTo(line.points[i].x, line.points[i].y);
      }
      context.stroke();
    });
  }

  // Draw all randomly generated lines
  function drawRandomLines() {
    context.clearRect(0, 0, canvas.width, canvas.height);

    context.lineWidth = 5;
    context.lineCap = 'round';
    context.strokeStyle = 'black';

    randomLines.forEach(function (linePoints) {
      context.beginPath();
      context.moveTo(linePoints[0].x, linePoints[0].y);
      for (var i = 1; i < linePoints.length; i++) {
        context.lineTo(linePoints[i].x, linePoints[i].y);
      }
      context.stroke();
    });
  }

</script>


<!-- Random Lines -->
<script>
  // Array to store randomly generated lines
  var randomLines = [];

  // Add wavy line traversal to the canvas
  function addRandomLines() {
    var n = 500; // Number of line segments
    var a = 0.1; // Angle aperture parameter
    var boundaryRange = 0.7; // Percentage of the canvas width/height to stay within
    var minLength = Math.min(canvas.width, canvas.height) * 0.3; // Minimum length of the line

    var canvasWidth = canvas.width;
    var canvasHeight = canvas.height;

    var centerX = canvasWidth / 2;
    var centerY = canvasHeight / 2;

    var boundaryWidth = canvasWidth * boundaryRange;
    var boundaryHeight = canvasHeight * boundaryRange;

    var startX = centerX - boundaryWidth / 2 + Math.random() * boundaryWidth;
    var startY = centerY - boundaryHeight / 2 + Math.random() * boundaryHeight;

    var x = startX;
    var y = startY;
    var angle = 0;
    var lineLength = 0;

    context.lineWidth = 5;
    context.lineCap = 'round';
    context.strokeStyle = 'black';

    var linePoints = []; // Array to store the points of the current line

    context.beginPath();
    context.moveTo(x, y);

    for (var k = 1; k <= n; k++) {
      var angleVariation = (2 * Math.random() - 1) * a * Math.PI;
      angle += angleVariation;

      // Calculate the maximum distance from the boundary
      var maxDistanceX = Math.min(boundaryWidth / 2 - Math.abs(x - centerX), boundaryWidth / 2);
      var maxDistanceY = Math.min(boundaryHeight / 2 - Math.abs(y - centerY), boundaryHeight / 2);

      var maxLength = Math.min(maxDistanceX, maxDistanceY);

      // Calculate the remaining length to reach the minimum length
      var remainingLength = minLength - lineLength;
      var r = Math.min(remainingLength, Math.random() * maxLength);

      x += r * Math.cos(angle);
      y += r * Math.sin(angle);

      lineLength += r;

      context.lineTo(x, y);
      linePoints.push({ x: x, y: y });

      // Exit the loop if the line reaches the minimum length
      if (lineLength >= minLength) {
        break;
      }
    }

    context.stroke();

    randomLines.push(linePoints); // Store the points of the line in the array
  }



  // Drawing random lines
  window.addEventListener('load', function() {
    // Call the function to add random lines when the page loads
    for (var i = 0; i < 5; i++) {
      addRandomLines();
    }
    // Clear the canvas
    context.clearRect(0, 0, canvas.width, canvas.height);
    // redraw random lines:
    drawRandomLines();
  });
</script>


</body>
</html>
